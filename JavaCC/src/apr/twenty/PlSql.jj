/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. PlSql.jj */
/*@egen*/ /**
* JJTree file
*/options{  STATIC = false;  IGNORE_CASE = true;                                                        
                                                            }PARSER_BEGIN(PlSql)package apr.twenty;import java.util.LinkedList;import java.util.LinkedList;import java.io.Reader;import java.io.FileInputStream;import apr.twenty.custom.*;import apr.twenty.tree.*;import java.util.HashSet;import java.util.Set;import java.util.Iterator;public class PlSql/*@bgen(jjtree)*/implements PlSqlTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTPlSqlState jjtree = new JJTPlSqlState();

/*@egen*/  public static void main(String args []) throws Throwable  {    if (args.length < 1)    {      args = new String []      {        "-"      }      ;    }    for (int a = 0;    a < args.length;    ++ a)    {      final String input = args [a];      final PlSql parser = new PlSql("-".equals(input) ? System.in : new FileInputStream(input));      try      {        Function rootNode = parser.Start();        rootNode.PrintElements();        Tree myTree = new Tree();        //myTree.buildTree(rootNode);      }      catch (Throwable t)      {        System.err.println(input + ":1: not parsed");        t.printStackTrace();      }    }  }  public Set < String > functions = new HashSet < String > ();  public Set < String > procedures = new HashSet < String > ();  public Set < String > tables = new HashSet < String > ();  public void reInit(Reader input)  {    ReInit(input);    functions.clear();    procedures.clear();    tables.clear();  }  private String lastObjectReference = null;  protected boolean seeTYPE()  {    return "TYPE".equalsIgnoreCase(getToken(1).image);  }}PARSER_END(PlSql)SKIP :{  " "| "\t"| "\r"| "\n"}/* Prefix      Meaning
    -------------------
    K_          Keyword
    O_          Operator
    S_          Substitutes
*/TOKEN : /* SQL and PLSQL Keywords. prefixed with K_ to avoid name clashes */{  < K_ALL : "ALL" >| < K_ALTER : "ALTER" >| < K_AND : "AND" >| < K_ANY : "ANY" >| < K_AS : "AS" >| < K_ASC : "ASC" >| < K_BEGIN : "BEGIN" >| < K_BETWEEN : "BETWEEN" >| < K_BINARY_INTEGER : "BINARY_INTEGER" >| < K_BOOLEAN : "BOOLEAN" >| < K_BY : "BY" >| < K_CALL : "CALL" >| < K_CASE : "CASE" >| < K_CAST : "CAST" >| < K_CHAR : "CHAR" >| < K_CLOSE : "CLOSE" >| < K_COMMENT : "COMMENT" >| < K_COMMIT : "COMMIT" >| < K_COMMITTED : "COMMITTED" >| < K_CONNECT : "CONNECT" >| < K_CONSTANT : "CONSTANT" >| < K_CONSTRAINT : "CONSTRAINT" >| < K_CONSTRAINTS : "CONSTRAINTS" >| < K_CREATE : "CREATE" >| < K_CURRENT : "CURRENT" >| < K_CURSOR : "CURSOR" >| < K_DATE : "DATE" >| < K_DECIMAL : "DECIMAL" >| < K_DECLARE : "DECLARE" >| < K_DEFAULT : "DEFAULT" >| < K_DELETE : "DELETE" >| < K_DESC : "DESC" >| < K_DISTINCT : "DISTINCT" >| < K_DO : "DO" >| < K_ELSE : "ELSE" >| < K_ELSIF : "ELSIF" >| < K_END : "END" >| < K_ESCAPE : "ESCAPE" >| < K_EXCEPTION : "EXCEPTION" >| < K_EXCEPTION_INIT : "EXCEPTION_INIT" >| < K_EXCLUSIVE : "EXCLUSIVE" >| < K_EXISTS : "EXISTS" >| < K_EXIT : "EXIT" >| < K_FETCH : "FETCH" >| < K_FLOAT : "FLOAT" >| < K_FOR : "FOR" >| < K_FORALL : "FORALL" >| < K_FROM : "FROM" >| < K_FULL : "FULL" >| < K_FUNCTION : "FUNCTION" >| < K_GOTO : "GOTO" >| < K_GROUP : "GROUP" >| < K_HAVING : "HAVING" >| < K_IF : "IF" >| < K_IN : "IN" >| < K_INDEX : "INDEX" >| < K_INNER : "INNER" >| < K_INSERT : "INSERT" >| < K_INTEGER : "INTEGER" >| < K_INTERSECT : "INTERSECT" >| < K_INTO : "INTO" >| < K_IS : "IS" >| < K_ISOLATION : "ISOLATION" >| < K_LEFT : "LEFT" >| < K_LIKE : "LIKE" >| < K_LOCK : "LOCK" >| < K_LOOP : "LOOP" >| < K_MERGE : "MERGE" >| < K_MINUS : "MINUS" >| < K_NATURAL : "NATURAL" >| < K_NOT : "NOT" >| < K_NOWAIT : "NOWAIT" >| < K_NULL : "NULL" >| < K_NULLS : "NULLS" >| < K_NUMBER : "NUMBER" >| < K_OF : "OF" >| < K_ON : "ON" >| < K_ONLY : "ONLY" >| < K_OPEN : "OPEN" >| < K_OR : "OR" >| < K_ORDER : "ORDER" >| < K_OUT : "OUT" >| < K_OVER : "OVER" >| < K_PACKAGE : "PACKAGE" >| < K_PARTITION : "PARTITION" >| < K_POSITIVE : "POSITIVE" >| < K_PRAGMA : "PRAGMA" >| < K_PRIOR : "PRIOR" >| < K_PROCEDURE : "PROCEDURE" >| < K_PX_GRANULE : "PX_GRANULE" >| < K_RAISE : "RAISE" >| < K_RANGE : "RANGE" >| < K_READ : "READ" >| < K_REAL : "REAL" >| < K_RECORD : "RECORD" >| < K_REF : "REF" >| < K_RETURN : "RETURN" >| < K_RETURNS : "RETURNS" >| < K_RETURNING : "RETURNING" >| < K_REVERSE : "REVERSE" >| < K_RIGHT : "RIGHT" >| < K_ROLLBACK : "ROLLBACK" >| < K_ROW : "ROW" >| < K_ROWS : "ROWS" >| < K_SAMPLE : "SAMPLE" >| < K_SAVEPOINT : "SAVEPOINT" >| < K_SELECT : "SELECT" >| < K_SERIALIZABLE : "SERIALIZABLE" >| < K_SET : "SET" >| < K_SHARE : "SHARE" >| < K_SIBLINGS : "SIBLINGS" >| < K_SKIP : "SKIP" >| < K_SMALLINT : "SMALLINT" >| < K_SQL : "SQL" >| < K_START : "START" >| < K_TABLE : "TABLE" >| < K_TEST : "TEST" >| < K_THEN : "THEN" >| < K_TO : "TO" >| < K_TRANSACTION : "TRANSACTION" >| < K_UNION : "UNION" >| < K_UNIQUE : "UNIQUE" >| < K_UPDATE : "UPDATE" >| < K_USE : "USE" >| < K_USING : "USING" >| < K_VALUES : "VALUES" >| < K_VARCHAR2 : "VARCHAR2" >| < K_VARCHAR : "VARCHAR" >| < K_WAIT : "WAIT" >| < K_WHEN : "WHEN" >| < K_WHERE : "WHERE" >| < K_WHILE : "WHILE" >| < K_WITH : "WITH" >| < K_WORK : "WORK" >| < K_WRITE : "WRITE" >}TOKEN : /* Numeric Constants */{  < S_NUMBER :    < FLOAT >  | < FLOAT >    (      [ "e", "E" ] ([ "-", "+" ])? < FLOAT >    )? >| < #FLOAT :    < INTEGER >  | < INTEGER > ("." < INTEGER >)?  | "." < INTEGER > >| < #INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}SPECIAL_TOKEN :{  < LINE_COMMENT : "--" (~[ "\r", "\n" ])* >| < MULTI_LINE_COMMENT :    "/*" (~[ "*" ])* "*"    (      "*"    |      (        ~[ "*", "/" ] (~[ "*" ])* "*"      )    )*    "/" >}TOKEN :{  < S_IDENTIFIER :    (< LETTER >)+    (      < DIGIT >    | < LETTER >    | < SPECIAL_CHARS >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #SPECIAL_CHARS :    "$"  | "_"  | "#" >| < S_BIND :    ":"    (      < S_NUMBER >    | < S_IDENTIFIER > ("." < S_IDENTIFIER >)?    ) >| < S_CHAR_LITERAL :    "'" (~[ "'" ])* "'"    (      "'" (~[ "'" ])* "'"    )* >| < S_QUOTED_IDENTIFIER : "\"" (~[ "\n", "\r", "\"" ])* "\"" >}Function Start() :{  Function func;}{  func = FunctionDeclaration()  {    return func;  }}Function FunctionDeclaration() :{  LinkedList < Parameter > pList;  Token t;  String ret;  FunctionBody myFuncB;  ScalarNode retExpr;}{  (    "FUNCTION" t = < S_IDENTIFIER > "(" pList = ParameterList() ")" "RETURNS" ret = BasicDataTypeDefinition() myFuncB = FunctionBody() "RETURN" retExpr = SQLExpr() ";"  )  {    return new Function(t.image, pList, ret, myFuncB, retExpr);  }}LinkedList < Parameter > ParameterList()       :{  LinkedList < Parameter > paramList = new LinkedList < Parameter > ();  Parameter temp;}{  (    temp = Parameter()    {      paramList.add(temp);    }    (      "," temp = Parameter()      {        paramList.add(temp);      }    )*  )  {    return paramList;  }}Parameter Parameter()       :{  Token t;}{  t = < S_IDENTIFIER >  {    return new Parameter(t.image);  }}String BasicDataTypeDefinition()       :{}{  "CHAR"  {    return new String("char");  }| "VARCHAR"  {    return new String("varchar");  }| "VARCHAR2"  {    return new String("varchar2");  }| "INTEGER"  {    return new String("int");  }| "NUMBER"  {    return new String("number");  }| "NATURAL"  {    return new String("natural");  }| "REAL"  {    return new String("real");  }| "FLOAT"  {    return new String("float");  }}FunctionBody FunctionBody()       :{  LinkedList < PLSQLStmt > myStmtList = new LinkedList < PLSQLStmt > ();  PLSQLStmt insertStmt;}{  (    insertStmt = PLSQLStmt()    {      myStmtList.add(insertStmt);    }  )+  {    return new FunctionBody(myStmtList);  }}PLSQLStmt PLSQLStmt()       :{  PLSQLStmt myStmt;}{  (    (      myStmt = AssignmentStmt()    | myStmt = DeclareStmt()    )    ";"  )  {    return myStmt;  }}AssignStatement AssignmentStmt()       :{  ScalarNode myExpr;  Token t;}{  (    t = < S_IDENTIFIER > "=" myExpr = SQLExpr()  )  {    return new AssignStatement("asgn", t.image, myExpr);  }}DeclareStmt DeclareStmt()       :{  String t;  LinkedList < String > varList;}{  (    "DECLARE" t = BasicDataTypeDefinition() varList = VariableList()  )  {    return new DeclareStmt("decl", varList, t);  }}LinkedList < String > VariableList() :{  LinkedList < String > strList = new LinkedList < String > ();  String temp;}{  (    temp = Variable()    {      strList.add(temp);    }    (      ","      (        temp = Variable()        {          strList.add(temp);        }      )    )*  )  {    return strList;  }}String Variable() :{  Token t;}{  t = < S_IDENTIFIER >  {    return new String(t.image);  }}ScalarNode SQLExpr() :{  SQLQueryNode n;  SimpleExp y;}{  y = SQLSimpleExpression()  {    return new ScalarNode(1, y);  }| n = SelectStatement()  {    return new ScalarNode(2, n);  }}String SimExpr()       :{  Token t;}{  t = < S_IDENTIFIER >  {    return t.image;  }}/**
		SQL Query Part
**/SQLQueryNode SelectStatement() :{  SelWithoutOrderNode sn = new SelWithoutOrderNode();  OrderByNode on = new OrderByNode();  boolean isOrderImposed = false;}{  sn = SelectWithoutOrder()  [    on = OrderByClause()    {      isOrderImposed = true;    }  ]  {    if (isOrderImposed)    {      on.addChild(sn);      return on;    }    else    {      return sn;    }  }  // [ ForUpdateClause() ]
  //[ "SKIP" ID("LOCKED") ]
}SelWithoutOrderNode SelectWithoutOrder() :{  SelWithoutOrderNode sn = new SelWithoutOrderNode();  SQLQueryNode n = new SQLQueryNode();  int type = 0;}{  n = SelectSet()  {    sn.add(n);  }  (    (      ("UNION"      {        type = 1; }      [        "ALL"        {          type = 2; }      ]      )    | "INTERSECT"      {        type = 3;      }    | "MINUS"      {        type = 4;      }    )    n = SelectSet()    {      sn.add(type, n);    }  )*  {    return sn;  }}SQLQueryNode SelectSet() :{  SQLQueryNode n = new SQLQueryNode();}{  n = Select()  {    return n;  }| "(" n = SubQuery() ")"  {    return n;  }}ProjectNode Select()      :{/*@bgen(jjtree) Sel */
  Sel jjtn000 = new Sel(this, JJTSEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  ProjectNode pn = new ProjectNode();  SelectNode sn = new SelectNode();  FromNode fn = new FromNode();  GroupByNode gn = new GroupByNode();  SQLPredicate hPred = new SQLPredicate();  int projectType = 0;  boolean isGroupBy = false;  boolean isWhere = false;}{/*@bgen(jjtree) Sel */
  try {
/*@egen*/  "SELECT"  [    "ALL"    {      projectType = 1;    }  | "DISTINCT"    {      projectType = 2;    }  | "UNIQUE"    {      projectType = 3;    }  ]/*@bgen(jjtree) Proj */
  {
    Proj jjtn001 = new Proj(this, JJTPROJ);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
  }
  try {
/*@egen*/  pn = SelectList()/*@bgen(jjtree)*/
  } catch (Throwable jjte001) {
    if (jjtc001) {
      jjtree.clearNodeScope(jjtn001);
      jjtc001 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte001 instanceof RuntimeException) {
      throw (RuntimeException)jjte001;
    }
    if (jjte001 instanceof ParseException) {
      throw (ParseException)jjte001;
    }
    throw (Error)jjte001;
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
    }
  }
/*@egen*/        {    pn.setType(projectType);  }/*@bgen(jjtree) From */
  {
    From jjtn002 = new From(this, JJTFROM);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
  }
  try {
/*@egen*/  //[IntoClause()]
  fn = FromClause()/*@bgen(jjtree)*/
  } catch (Throwable jjte002) {
    if (jjtc002) {
      jjtree.clearNodeScope(jjtn002);
      jjtc002 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte002 instanceof RuntimeException) {
      throw (RuntimeException)jjte002;
    }
    if (jjte002 instanceof ParseException) {
      throw (ParseException)jjte002;
    }
    throw (Error)jjte002;
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
    }
  }
/*@egen*/        [/*@bgen(jjtree) where */
    {
      where jjtn003 = new where(this, JJTWHERE);
      boolean jjtc003 = true;
      jjtree.openNodeScope(jjtn003);
    }
    try {
/*@egen*/    sn = WhereClause()/*@bgen(jjtree)*/
    } catch (Throwable jjte003) {
      if (jjtc003) {
        jjtree.clearNodeScope(jjtn003);
        jjtc003 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte003 instanceof RuntimeException) {
        throw (RuntimeException)jjte003;
      }
      if (jjte003 instanceof ParseException) {
        throw (ParseException)jjte003;
      }
      throw (Error)jjte003;
    } finally {
      if (jjtc003) {
        jjtree.closeNodeScope(jjtn003, true);
      }
    }
/*@egen*/           {      isWhere = true;    }  ]  [    gn = GroupByClause()    {      isGroupBy = true;    }    [      hPred = HavingClause()      {        gn.setHavingPred(hPred);      }    ]  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (isWhere)    {      sn.setChildNode(fn);      if (isGroupBy)      {        gn.setChildNode(sn);        pn.setChildNode(gn);      }      else      {        pn.setChildNode(sn);      }    }    else    {      if (isGroupBy)      {        gn.setChildNode(fn);        pn.setChildNode(gn);      }      else      {        pn.setChildNode(fn);      }    }    return pn;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}/* Checks for whatever follows  SELECT */ProjectNode SelectList() :{  ProjectNode pn = new ProjectNode();  SelectItem si = new SelectItem();  boolean isProjectAll = false;}{  "*"  {    return new ProjectNode(isProjectAll);  }| si = SelectItem()  {    pn.add(si);  }  (    "," si = SelectItem()    {      pn.add(si);    }  )*  {    return pn;  }}SelectItem SelectItem()       :{  SimpleExp e;  String alias = new String();  boolean isAlias = false;  SelectItem si = new SelectItem();}{  (    //LOOKAHEAD(2) OracleObjectName()".*" // table.*
    //| LOOKAHEAD(4) OracleObjectName()"." OracleObjectName() ".*" // schema.table.*
    e = SQLSimpleExpression() // column name or expression
  )  [    [ "AS" ] alias = SelectItemAlias()    {      isAlias = true;    }  ]  {    if (isAlias)    {      si.add(e, alias);    }    else    {      si.add(e);    }    return si;  }}String SelectItemAlias() :{  String alias;}{  alias = OracleObjectName()  {    return alias;  }  // Some keywords are acceptable as aliases:
  //| "RETURNING"
  //| "WHEN"
}SQLQueryNode SubQuery() : /**************************/{  SQLQueryNode sn = new SQLQueryNode();}{  sn = SelectStatement()  {    return sn;  }}FromNode FromClause() :{  FromNode fn = new FromNode();  QueryTableExp e = new QueryTableExp();}{  "FROM" e = QueryTableExpression()  {    fn.add(e);  }  (    "," e = QueryTableExpression()    {      fn.add(e);    }  )*  {    return fn;  }}SelectNode WhereClause() :{  SQLPredicate p = new SQLPredicate();}{  "WHERE" p = SQLExpression()  {    return new SelectNode(p);  }}GroupByNode GroupByClause() :{  GroupByNode gn = new GroupByNode();  LinkedList < String > grpExpList = new LinkedList< String >();  String s;}{  "GROUP" "BY" s = TableColumn()  {    grpExpList.add(s);  }  (    "," TableColumn()    {      grpExpList.add(s);    }  )*  {    gn.setGrpExpList(grpExpList);    return gn;  }}SQLPredicate HavingClause() :{  SQLPredicate pred;}{  "HAVING" pred = SQLExpression()  {    return pred;  }}OrderByNode OrderByClause() :{  OrderByNode on = new OrderByNode();  OrderByExpression e = new OrderByExpression();}{  "ORDER" [ "SIBLINGS" ] "BY" e = OrderByExpression()  {    on.addExp(e);  }  (    "," e = OrderByExpression()    {      on.addExp(e);    }  )*  {    return on;  }}OrderByExpression OrderByExpression() :{  SimpleExp e;  int orderType = 0;  boolean isOrderType = false;  OrderByExpression oe = new OrderByExpression();}{  e = SQLSimpleExpression()  [    "ASC"    {      orderType = 1;    }  | "DESC"    {      orderType = 2;    }  ]  {    oe.setData(e, orderType);    return oe;  }  //["NULLS" ID("LAST")]
}SimpleExp SQLSimpleExpression() :{  MultiplyExp rand1;  SimpleExp rand2 = new SimpleExp();  String rator = "";  boolean isBinaryExpr = false;}{  rand1 = SQLMultiplicativeExpression()  [    rator = SimpleOp() rand2 = SQLSimpleExpression()    {      isBinaryExpr = true;    }  ]  {    if (isBinaryExpr)    {      return new SimpleExp(rand1, rator, rand2);    }    else    {      return new SimpleExp(rand1);    }  }}String SimpleOp() :{}{  "+"  {    return new String("+");  }| "-"  {    return new String("-");  }}MultiplyExp SQLMultiplicativeExpression() :{  ExponentExp rand1;  MultiplyExp rand2 = new MultiplyExp();  String rator = "";  boolean isBinaryExpr = false;}{  rand1 = SQLExponentExpression()  [    rator = MultiplyOp() rand2 = SQLMultiplicativeExpression()    {      isBinaryExpr = true;    }  ]  {    if (isBinaryExpr)    {      return new MultiplyExp(rand1, rator, rand2);    }    else    {      return new MultiplyExp(rand1);    }  }}String MultiplyOp() :{}{  "*"  {    return new String("*");  }| "/"  {    return new String("/");  }}ExponentExp SQLExponentExpression() :{  UnaryExp rand1;  ExponentExp rand2 = new ExponentExp();  boolean isBinaryExpr = false;}{  rand1 = SQLUnaryExpression()  [    "**" rand2 = SQLExponentExpression()    {      isBinaryExpr = true;    }  ]  {    if (isBinaryExpr)    {      return new ExponentExp(rand1, rand2);    }    else    {      return new ExponentExp(rand1);    }  }}UnaryExp SQLUnaryExpression() :{  PrimaryExp rand;  String s = "";  boolean isSignAssigned = false;}{  [    "+"    {      s = "+";      isSignAssigned = true;    }  | "-"    {      s = "-";      isSignAssigned = true;    }  ]  rand = SQLPrimaryExpression()  {    if (isSignAssigned)    {      return new UnaryExp(s, rand);    }    else    {      return new UnaryExp(rand);    }  }}PrimaryExp SQLPrimaryExpression() :{  Token t;  String s;}{  t = < S_NUMBER >  {    return new PrimaryExp(1, Integer.parseInt(t.image));  }  //| <S_CHAR_LITERAL>
| "NULL"  {    return new PrimaryExp(3);  }  //| SQLCaseExpression()
  /*| BindVariable()
  | LOOKAHEAD(2) SQLCastExpression()
  | LOOKAHEAD(IntervalExpression()) IntervalExpression()
  | LOOKAHEAD(OuterJoinExpression()) OuterJoinExpression()
  | LOOKAHEAD(FunctionReference() "(") FunctionCall()*/| s = TableColumn()  {    return new PrimaryExp(2, s);  } // Might be a call to a parameter-less function.
}String TableColumn()       :{  String s;}{  s = ObjectReference()  {    return s;  }}String OracleObjectName() : /********************/{}{  < S_IDENTIFIER >  {    return token.image;  }| < S_QUOTED_IDENTIFIER >  {    String s = token.image;    return s.substring(1, s.length() - 1);  }}/*
void TableReference():
{}
{
    "ONLY" "(" QueryTableExpression() ")"
  | QueryTableExpression()
}
*/String ObjectReference() :{  String s;  StringBuilder name = new StringBuilder();}{  s = OracleObjectName()  {    name.append(s);  }  [    "." s = OracleObjectName()    {      name.append(".").append(s);    }    [      "." s = OracleObjectName()      {        name.append(".").append(s);      }    ]  ]  //[ "@" ("!" | s=TNSName()   {name.append("@").append(s);} )] // remote reference
  // The @! idiom is undocumented, but accepted by Oracle software.
  {    return lastObjectReference = name.toString();  }}String TableName() : /**************************/{  String s;  StringBuilder name = new StringBuilder();}{  // schema.table@link
  s = OracleObjectName()  {    name.append(s);    tables.add(name.toString().toUpperCase());    return name.toString();  }  //[ "." s=OracleObjectName() {name.append(".").append(s);} ]
  //[ "@" s=TNSName()          {name.append("@").append(s);} ]
}QueryTableExp QueryTableExpression() :{  String tableName;  SQLQueryNode n = new SQLQueryNode();  int type = 0;}{  (    tableName = TableName() // might also be a query name
    {      return new QueryTableExp(tableName);    }    //| TableCollectionExpression()
  | LOOKAHEAD(3)    "(" n = SubQuery() ")"    {      return new QueryTableExp(n);    }    //| "(" TableReference() ")"
    //| BindVariable() // not valid SQL, but appears in StatsPack SQL text
  )  //["PX_GRANULE" "(" <S_NUMBER> "," <S_IDENTIFIER> "," <S_IDENTIFIER> ")"]
  // ["SAMPLE" [ID("BLOCK")] "(" <S_NUMBER> ")"]
  [ OracleObjectName() ] // alias
  //(Join())*
}SQLPredicate SQLExpression() :{  SQLPredicate rand1;  SQLPredicate rand2 = null;  boolean isBinaryPred = false;}{  rand1 = SQLAndExpression()  [    "OR" rand2 = SQLExpression()    {      isBinaryPred = true;    }  ]  {    if (isBinaryPred)    {      return new SQLOrPred(rand1, rand2);    }    else    {      return rand1;    }  }}SQLPredicate SQLAndExpression() :{  SQLPredicate rand1;  SQLPredicate rand2 = null;  boolean isBinaryPred = false;}{  rand1 = SQLUnaryLogicalExpression()  [    "AND" rand2 = SQLAndExpression()    {      isBinaryPred = true;    }  ]  {    if (isBinaryPred)    {      return new SQLAndPred(rand1, rand2);    }    else    {      return rand1;    }  }}SQLPredicate SQLUnaryLogicalExpression() :{  SQLPredicate rand;  //SQLExistsPred exiPred;
  //SQLRelExprPred relPred;
  boolean isNeg = false;}{  LOOKAHEAD(2)  rand = ExistsClause()  {    return rand;  }|  (    [      "NOT"      {        isNeg = true; }    ]    rand = SQLRelationalExpression()  )  {    if (isNeg) rand.setNeg(isNeg);    return rand;  }}SQLPredicate ExistsClause() :{  SQLExistsPred ret = new SQLExistsPred();  boolean isNeg = false;}{  [    "NOT"    {      isNeg = true;    }  ]  "EXISTS" "(" SubQuery() ")"  {    if (isNeg) ret.setNeg(isNeg);    return ret;  }}/*here*/SQLPredicate SQLRelationalExpression() :{  SimpleExp leftRand;  boolean isNeg = false;  Pred_RightOperand rightRand = new Pred_RightOperand();}{  /* Only after looking past "(", Expression() and "," we will know that
       it is expression list */  leftRand = SQLSimpleExpression()  /* Lookahead(2) is required because of NOT IN,NOT BETWEEN and NOT LIKE */  (    rightRand = SQLRelationalOperatorExpression()  | LOOKAHEAD(2)    rightRand = SQLInClause()  | LOOKAHEAD(2)    rightRand = SQLBetweenClause()  | LOOKAHEAD(2)    rightRand = SQLLikeClause()    /*|  rightRand = IsNullClause()*/  )  {    return new SQLRelExprPred(leftRand, rightRand);  }}LinkedList < SQLPredicate > SQLExpressionList() :{  LinkedList < SQLPredicate > predList = new LinkedList < SQLPredicate > ();  SQLPredicate temp;}{  temp = SQLExpression()  {    predList.add(temp);  }  (    "," temp = SQLExpression()    {      predList.add(temp);    }  )*  {    return predList;  }}Pred_RightOperand SQLRelationalOperatorExpression() :{  String relOp;  SQLQueryNode n;  SimpleExp s;  int type;}{  relOp = Relop()  /* Only after seeing an ANY/ALL or "(" followed by a SubQuery() we can
    determine that is is a sub-query
    */  (    LOOKAHEAD("ANY"  | "ALL"  | "(" "SELECT")    (      [        "ALL"        {          type = 1; }      | "ANY"        {          type = 2; }      ]      "(" /*n =*/SubQuery() ")"    )    {      return new SQLRelOpExp();      //return new SQLRelOpExp(relOp, type, null, n);
    }  | s = SQLSimpleExpression()    {      return new SQLRelOpExp();      //return new SQLRelOpExp(relOp, 3, s, null);
    }  )}String Relop() : /********************/{}{  "="  {    return "=";  }| "!" "="  {    return "!=";  }| "#"  {    return "#";  }| LOOKAHEAD(2)  ">" "="  {    return ">=";  }| ">"  {    return ">";  }| LOOKAHEAD(2)  "<" ">"  {    return "<>";  }| LOOKAHEAD(2)  "<" "="  {    return "<=";  }| "<"  {    return "<";  }}Pred_RightOperand SQLInClause() :{  boolean isNeg = false;  SQLQueryNode n = null;}{  [    "NOT"    {      isNeg = true;    }  ]  "IN" "("  (    SubQuery() /*| SQLExpressionList()*/  )  ")"  {    return new SQLInClause(isNeg, n);  }}Pred_RightOperand SQLBetweenClause() :{  SimpleExp lowerLim;  SimpleExp upperLim;  boolean isNeg = false;}{  [    "NOT"    {      isNeg = true;    }  ]  "BETWEEN" lowerLim = SQLSimpleExpression() "AND" upperLim = SQLSimpleExpression()  {    return new SQLBetweenClause(isNeg, lowerLim, upperLim);  }}Pred_RightOperand SQLLikeClause() :{  SimpleExp cmpExp;  SimpleExp escapeExp = null;  boolean isNeg = false;}{  [    "NOT"    {      isNeg = true;    }  ]  "LIKE" cmpExp = SQLSimpleExpression() [ "ESCAPE" escapeExp = SQLSimpleExpression() ]  {    if (escapeExp == null)    {      return new SQLLikeClause(isNeg, cmpExp);    }    else    {      return new SQLLikeClause(isNeg, cmpExp, escapeExp);    }  }}